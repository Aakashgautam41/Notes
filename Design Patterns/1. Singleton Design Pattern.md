Awesome 🔥 Let’s dive into **Singleton Pattern** step by step.

---

# 🎯 Singleton Design Pattern

---

## 📝 Problem

Sometimes in an application, you need **only one instance** of a class.  
Examples:

- Logging service (you don’t want multiple loggers writing inconsistently).
    
- Database connection pool (too many instances = resource overhead).
    
- Configuration manager (settings should be consistent).
    

👉 If we allow multiple objects, it can lead to **inconsistent states** or **high resource consumption**.

---

## 💡 Solution

- Ensure that **only one instance** of the class is created.
    
- Provide a **global point of access** to that instance.
    

---

## 🖥 Code Examples

### 1. **Basic Singleton (Not Thread-Safe)**

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {} // private constructor

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // lazy initialization
        }
        return instance;
    }
}
```

❌ Problem: Not thread-safe. Two threads may create separate instances.

---

### 2. **Thread-Safe Singleton (Synchronized Method)**

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

✅ Thread-safe but slower due to synchronization overhead.

---

### 3. **Double-Checked Locking (Best Practice for Lazy Init)**

```java
public class Singleton {
    private static volatile Singleton instance; // volatile required

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) { // check again inside lock
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

✅ Efficient + thread-safe. Most common in interviews.

---

### 4. **Eager Initialization**

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

✅ Thread-safe, simple.  
❌ But creates instance even if not used.

---

### 5. **Bill Pugh Singleton (Best for Java)**

```java
public class Singleton {
    private Singleton() {}

    // Inner static helper class
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

✅ Lazy, thread-safe, no synchronization overhead.  
👉 Preferred way in modern Java.

---

### 6. **Enum Singleton (Most Robust)**

```java
public enum Singleton {
    INSTANCE;

    public void showMessage() {
        System.out.println("Hello from Singleton Enum!");
    }
}
```

✅ Thread-safe, handles serialization, reflection attacks.  
👉 Joshua Bloch (Effective Java) recommends this.

---

## 🌍 Real-World Use Cases

- `Runtime.getRuntime()` in Java
    
- `Logger` frameworks (Log4j, SLF4J)
    
- `Spring Beans` by default are Singletons
    
- `DriverManager` for JDBC connections
    

---

## 💬 Interview Q&A

**Q1: Why use Singleton?**  
👉 To control object creation, ensure only one instance, and save resources.

**Q2: How do you make Singleton thread-safe?**  
👉 Use synchronized method, double-checked locking, or static inner class.

**Q3: What are drawbacks of Singleton?**  
👉

- Difficult to unit test (tight coupling, hidden dependency).
    
- Can lead to **global state**, which makes debugging harder.
    

**Q4: Which Singleton is best in Java?**  
👉 **Bill Pugh method** or **Enum Singleton** (preferred for robustness).

**Q5: Difference between Singleton and Static Class?**

- Singleton → Object-oriented, can implement interfaces, supports polymorphism.
    
- Static Class → No instance, all methods/fields are static.
    

---
Let’s create a **very small, runnable Singleton program** so you can code it yourself and see it in action.

We’ll use the **lazy initialization with thread safety (Bill Pugh method)** — cleanest way in Java.

---

## 🖥 Singleton Example Program

```java
// File: SingletonDemo.java

class Singleton {
    // 1. Private constructor (so no one else can create objects)
    private Singleton() {
        System.out.println("Singleton instance created!");
    }

    // 2. Inner static helper class
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // 3. Public method to provide global access
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }

    // Example method
    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}

public class SingletonDemo {
    public static void main(String[] args) {
        // Fetch the same Singleton instance multiple times
        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();

        obj1.showMessage();

        // Verify both references are the same object
        System.out.println("Are obj1 and obj2 same? " + (obj1 == obj2));
    }
}
```

---

## ✅ Expected Output

```
Singleton instance created!
Hello from Singleton!
Are obj1 and obj2 same? true
```

- `"Singleton instance created!"` prints only **once**, no matter how many times you call `getInstance()`.
    
- `(obj1 == obj2)` is `true`, proving only one object exists.
    

---
Let’s walk through the **execution flow** of your Singleton program step by step. I’ll break it down into **what happens in memory** and **why certain lines execute only once**.

---

## 🖥 Code (for reference)

```java
class Singleton {
    private Singleton() {
        System.out.println("Singleton instance created!");
    }

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }

    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}

public class SingletonDemo {
    public static void main(String[] args) {
        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();

        obj1.showMessage();
        System.out.println("Are obj1 and obj2 same? " + (obj1 == obj2));
    }
}
```

---

## 🔄 Flow of Execution

### Step 1: Program start

- JVM starts executing `main()` in `SingletonDemo`.
    

---

### Step 2: First call → `Singleton.getInstance()`

```java
Singleton obj1 = Singleton.getInstance();
```

1. JVM looks for `getInstance()` inside `Singleton`.
    
2. `getInstance()` returns `Holder.INSTANCE`.
    
3. At this point, the **`Holder` class is loaded for the first time**.
    
    - JVM loads `Holder`.
        
    - Inside `Holder`, the line
        
        ```java
        private static final Singleton INSTANCE = new Singleton();
        ```
        
        executes.
        
4. The private constructor `Singleton()` is called → prints:
    
    ```
    Singleton instance created!
    ```
    
5. The `INSTANCE` is created and stored in memory.
    
6. `obj1` now points to this instance.
    

---

### Step 3: Second call → `Singleton.getInstance()`

```java
Singleton obj2 = Singleton.getInstance();
```

1. Again, `getInstance()` is called.
    
2. But now, `Holder` is **already loaded** and `INSTANCE` is **already created**.
    
3. JVM simply returns the same `INSTANCE`.
    
4. No new object is created, so the constructor is **not called again**.
    

---

### Step 4: Calling `showMessage()`

```java
obj1.showMessage();
```

- Calls method on the Singleton instance.
    
- Prints:
    
    ```
    Hello from Singleton!
    ```
    

---

### Step 5: Comparison

```java
System.out.println("Are obj1 and obj2 same? " + (obj1 == obj2));
```

- Both `obj1` and `obj2` point to the **same object reference**.
    
- `(obj1 == obj2)` → `true`.
    
- Prints:
    
    ```
    Are obj1 and obj2 same? true
    ```
    

---

## ✅ Final Output

```
Singleton instance created!
Hello from Singleton!
Are obj1 and obj2 same? true
```

---

## 🔑 Key Takeaways

- The **instance is created only when needed** (lazy initialization).
    
- **Class loading is thread-safe** → `Holder.INSTANCE` is guaranteed to be initialized only once, no matter how many threads call `getInstance()`.
    
- All subsequent calls just return the same object.
    

---
Let’s now see what happens when **multiple threads** call `getInstance()` simultaneously. This is where the **static inner class Singleton (a.k.a. Bill Pugh Singleton)** really shines.

---

## 👩‍💻 Updated Code with Threads

```java
class Singleton {
    private Singleton() {
        System.out.println("Singleton instance created by " + Thread.currentThread().getName());
    }

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        Runnable task = () -> {
            Singleton obj = Singleton.getInstance();
            System.out.println(Thread.currentThread().getName() + " got instance: " + obj.hashCode());
        };

        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");
        Thread t3 = new Thread(task, "Thread-3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

---

## 🔄 Flow of Execution

### Step 1: Threads start

- `Thread-1`, `Thread-2`, `Thread-3` all call `getInstance()` nearly at the same time.
    

---

### Step 2: Class loading (happens once)

- JVM checks if `Holder` class is loaded.
    
- If **not loaded yet**, JVM **synchronously** loads `Holder` class and initializes `INSTANCE`.
    
- This is guaranteed by JVM’s **class loader mechanism** (thread-safe by design).
    

So:

- Only **one thread** (say `Thread-1`) actually triggers the `new Singleton()`.
    
- The line
    
    ```java
    private static final Singleton INSTANCE = new Singleton();
    ```
    
    runs once.
    
- Constructor prints:
    
    ```
    Singleton instance created by Thread-1
    ```
    

---

### Step 3: Other threads proceed

- `Thread-2` and `Thread-3` also enter `getInstance()`.
    
- But now `Holder.INSTANCE` is already initialized.
    
- They just return the same reference.
    

---

### Step 4: Printing hashCodes

- All threads print the **same hashCode**, proving only one object exists:
    
    ```
    Thread-1 got instance: 12345678
    Thread-2 got instance: 12345678
    Thread-3 got instance: 12345678
    ```
    

---

## ✅ Why No Race Condition?

- **Class loading in JVM is synchronized per classloader**.
    
- That means two threads can’t load the same class at the same time.
    
- So, `INSTANCE` initialization is atomic and happens once.
    

---

## 🔑 Key Takeaway

- Even if **1000 threads** call `getInstance()` at once, only **one object is created**.
    
- That’s why the **static inner class approach** is both **lazy** and **thread-safe** without needing `synchronized` or **double-checked locking**.
    

---
