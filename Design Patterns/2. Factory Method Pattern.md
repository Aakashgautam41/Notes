Let‚Äôs dive into the **Factory Method Pattern** ‚Äî one of the most asked design patterns in interviews (after Singleton).

---

# üéØ Factory Method Pattern

## 1. **Problem**

- You want to create objects, but you don‚Äôt want your code to be tightly coupled to specific classes (`new` everywhere).
    
- Example: A system that needs to create different types of **shapes** (Circle, Square, Rectangle). If you use `new` directly, adding a new shape would force you to modify existing code (violates **Open/Closed Principle**).
    

---

## 2. **Solution**

- Define a **common interface** for objects.
    
- Create a **factory method** that decides which object to create.
    
- Clients call the **factory** instead of using `new`.
    

---

## 3. **Code Example**

```java
// Step 1: Product Interface
interface Shape {
    void draw();
}

// Step 2: Concrete Products
class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing a Square");
    }
}

// Step 3: Factory
class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}

// Step 4: Client
public class FactoryDemo {
    public static void main(String[] args) {
        ShapeFactory factory = new ShapeFactory();

        Shape s1 = factory.getShape("CIRCLE");
        s1.draw();

        Shape s2 = factory.getShape("SQUARE");
        s2.draw();
    }
}
```

---

## 4. **Flow of Execution**

1. `main()` creates `ShapeFactory`.
    
2. Calls `getShape("CIRCLE")`.
    
    - Factory checks input, creates `new Circle()`, returns it.
        
    - `draw()` prints `"Drawing a Circle"`.
        
3. Calls `getShape("SQUARE")`.
    
    - Returns `new Square()`.
        
    - `draw()` prints `"Drawing a Square"`.
        

---

## 5. **Real-World Use Cases**

- `DriverManager.getConnection()` in JDBC ‚Üí returns different DB connections (MySQL, Oracle, PostgreSQL).
    
- `DocumentBuilderFactory.newInstance()` in XML parsing.
    
- Spring‚Äôs `BeanFactory` (creates beans without `new`).
    

---

## 6. **Interview Q&A**

**Q1. What is the Factory Method Pattern?**  
‚û°Ô∏è It‚Äôs a creational design pattern where object creation is delegated to a factory method instead of using `new` directly.

**Q2. How is it different from Abstract Factory?**  
‚û°Ô∏è Factory Method ‚Üí Creates **one product at a time**.  
‚û°Ô∏è Abstract Factory ‚Üí Creates **families of related products**.

**Q3. Benefits of Factory Method?**

- Loose coupling (clients don‚Äôt depend on concrete classes).
    
- Code is easier to extend (just add new product class, modify factory).
    
- Centralized object creation logic.
    

---

Let‚Äôs replace the **shapes** with something **real-world & practical**.

I‚Äôll take the example of a **Notification System** üöÄ (very common in interviews and projects).

---

# Factory Method Pattern ‚Äì Real Example: Notifications

## 1. **Problem**

Your application needs to send **notifications** (Email, SMS, Push).

- If you directly use `new EmailNotification()`, `new SMSNotification()` everywhere, the code becomes hard to maintain.
    
- Tomorrow, if you add **WhatsAppNotification**, you‚Äôll need to modify many parts of the code.
    

---

## 2. **Solution**

- Create a **Notification interface** (common behavior).
    
- Implement specific notification classes.
    
- Use a **NotificationFactory** to create the right notification object.
    
- Client code just asks the factory ‚Üí doesn‚Äôt care about `new`.
    

---

## 3. **Code Example**

```java
// Step 1: Product Interface
interface Notification {
    void notifyUser(String message);
}

// Step 2: Concrete Products
class EmailNotification implements Notification {
    @Override
    public void notifyUser(String message) {
        System.out.println("Sending EMAIL with message: " + message);
    }
}

class SMSNotification implements Notification {
    @Override
    public void notifyUser(String message) {
        System.out.println("Sending SMS with message: " + message);
    }
}

class PushNotification implements Notification {
    @Override
    public void notifyUser(String message) {
        System.out.println("Sending PUSH notification with message: " + message);
    }
}

// Step 3: Factory
class NotificationFactory {
    public Notification createNotification(String type) {
        if (type == null) return null;

        switch (type.toUpperCase()) {
            case "EMAIL":
                return new EmailNotification();
            case "SMS":
                return new SMSNotification();
            case "PUSH":
                return new PushNotification();
            default:
                throw new IllegalArgumentException("Unknown notification type: " + type);
        }
    }
}

// Step 4: Client
public class FactoryDemo {
    public static void main(String[] args) {
        NotificationFactory factory = new NotificationFactory();

        Notification email = factory.createNotification("EMAIL");
        email.notifyUser("Hello via Email!");

        Notification sms = factory.createNotification("SMS");
        sms.notifyUser("Hello via SMS!");

        Notification push = factory.createNotification("PUSH");
        push.notifyUser("Hello via Push Notification!");
    }
}
```

---

## 4. **Flow of Execution**

1. `main()` calls `factory.createNotification("EMAIL")`.
    
    - Factory checks `"EMAIL"`, returns `new EmailNotification()`.
        
    - Calls `notifyUser("Hello via Email!")`.
        
2. Same for SMS & Push.
    

---

## 5. **Real-World Use Cases**

- Payment Gateways: Factory creates the right payment processor (`PayPal`, `Stripe`, `Razorpay`).
    
- Logging Frameworks: Logger factory creates the right logger (Console, File, Cloud).
    
- JDBC: `DriverManager.getConnection()` gives different DB connections (MySQL, Oracle, PostgreSQL).
    

---

## 6. **Interview Q&A**

**Q1. Why use Factory here instead of `new` directly?**  
‚û°Ô∏è Loose coupling: Client doesn‚Äôt know which class it‚Äôs using, just calls factory.  
‚û°Ô∏è Open/Closed principle: Add `WhatsAppNotification` later without touching client code.

**Q2. What happens if we don‚Äôt use a factory?**  
‚û°Ô∏è Client would have `if/else` or `switch` everywhere ‚Üí messy, tightly coupled.

**Q3. Where do we see Factory in Java?**

- `Calendar.getInstance()`
    
- `NumberFormat.getInstance()`
    
- `Logger.getLogger()`
    

---

Let‚Äôs level up the **Notification Example** from Factory ‚Üí **Abstract Factory**.

---

# üé® Abstract Factory Pattern ‚Äì Notifications with Themes

## 1. **Problem**

With Factory Method, we created notifications (Email, SMS, Push).  
üëâ But now the business wants **themed notifications**:

- **Light Theme Notifications**
    
- **Dark Theme Notifications**
    

Each theme changes how messages are displayed (e.g., colors, formatting).  
If we use Factory Method alone ‚Üí code will explode with conditions.

---

## 2. **Solution**

Abstract Factory provides:

- A **family of related objects** (here: Email, SMS, Push ‚Äì all in Light Theme or Dark Theme).
    
- A way to **create objects without specifying exact classes**.
    

---

## 3. **Code Example**

```java
// Step 1: Abstract Product Interfaces
interface Notification {
    void notifyUser(String message);
}

// Step 2: Concrete Product Variants

// Light Theme
class LightEmailNotification implements Notification {
    public void notifyUser(String message) {
        System.out.println("[LIGHT EMAIL] " + message);
    }
}

class LightSMSNotification implements Notification {
    public void notifyUser(String message) {
        System.out.println("[LIGHT SMS] " + message);
    }
}

class LightPushNotification implements Notification {
    public void notifyUser(String message) {
        System.out.println("[LIGHT PUSH] " + message);
    }
}

// Dark Theme
class DarkEmailNotification implements Notification {
    public void notifyUser(String message) {
        System.out.println("[DARK EMAIL] " + message);
    }
}

class DarkSMSNotification implements Notification {
    public void notifyUser(String message) {
        System.out.println("[DARK SMS] " + message);
    }
}

class DarkPushNotification implements Notification {
    public void notifyUser(String message) {
        System.out.println("[DARK PUSH] " + message);
    }
}

// Step 3: Abstract Factory
interface NotificationFactory {
    Notification createEmailNotification();
    Notification createSMSNotification();
    Notification createPushNotification();
}

// Step 4: Concrete Factories
class LightThemeNotificationFactory implements NotificationFactory {
    public Notification createEmailNotification() {
        return new LightEmailNotification();
    }
    public Notification createSMSNotification() {
        return new LightSMSNotification();
    }
    public Notification createPushNotification() {
        return new LightPushNotification();
    }
}

class DarkThemeNotificationFactory implements NotificationFactory {
    public Notification createEmailNotification() {
        return new DarkEmailNotification();
    }
    public Notification createSMSNotification() {
        return new DarkSMSNotification();
    }
    public Notification createPushNotification() {
        return new DarkPushNotification();
    }
}

// Step 5: Client
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        // Suppose user selected Light Theme
        NotificationFactory factory = new LightThemeNotificationFactory();

        Notification email = factory.createEmailNotification();
        Notification sms = factory.createSMSNotification();
        Notification push = factory.createPushNotification();

        email.notifyUser("Hello via Email!");
        sms.notifyUser("Hello via SMS!");
        push.notifyUser("Hello via Push Notification!");

        // Switching to Dark Theme
        factory = new DarkThemeNotificationFactory();

        email = factory.createEmailNotification();
        sms = factory.createSMSNotification();
        push = factory.createPushNotification();

        email.notifyUser("Dark Email");
        sms.notifyUser("Dark SMS");
        push.notifyUser("Dark Push");
    }
}
```

---

## 4. **Flow of Execution**

1. `main()` picks a theme (Light or Dark).
    
2. Calls the **factory** ‚Üí which produces the correct variant (Light/Dark).
    
3. Client code doesn‚Äôt care whether it‚Äôs `LightEmailNotification` or `DarkEmailNotification`.
    

---

## 5. **Real-World Use Cases**

- **UI frameworks**: Light vs Dark theme widgets (`Button`, `TextBox`, `Menu`).
    
- **Cloud Providers**: Different factories for AWS, Azure, GCP services.
    
- **Database Drivers**: JDBC `Connection`, `Statement`, `ResultSet` families.
    

---

## 6. **Interview Q&A**

**Q1. How is Abstract Factory different from Factory Method?**  
‚û°Ô∏è Factory Method ‚Üí creates one type of object (e.g., only EmailNotification).  
‚û°Ô∏è Abstract Factory ‚Üí creates a **family of related objects** (Email + SMS + Push, all themed).

**Q2. Where is Abstract Factory used in Java?**

- `javax.xml.parsers.DocumentBuilderFactory` (creates different parser families).
    
- `javax.xml.transform.TransformerFactory`.
    

**Q3. What principle does it follow?**  
‚û°Ô∏è **Dependency Inversion** ‚Äì client depends on abstraction, not concrete classes.  
‚û°Ô∏è **Open/Closed** ‚Äì can add new themes without touching client.

---

Great üëç Here‚Äôs a **side-by-side comparison table** for **Factory Method vs Abstract Factory** that you can directly use in interviews:

---

# üè≠ Factory Method vs Abstract Factory

| Aspect                 | Factory Method                                                                                             | Abstract Factory                                                                                                       |
| ---------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| **Definition**         | Defines an interface for creating a single product, but lets subclasses decide which class to instantiate. | Provides an interface for creating **families of related objects** without specifying their concrete classes.          |
| **Scope**              | Focused on creating **one product at a time**.                                                             | Focused on creating **multiple related products together**.                                                            |
| **Complexity**         | Simpler, involves fewer classes.                                                                           | More complex, involves multiple factories and product families.                                                        |
| **Return Type**        | Returns a single product (e.g., EmailNotification).                                                        | Returns a group/family of products (e.g., Email + SMS + Push in Light Theme).                                          |
| **Use Case Example**   | A factory that returns only one type of notification (Email, SMS, Push).                                   | A factory that returns themed notifications (Light Email, Light SMS, Light Push) vs (Dark Email, Dark SMS, Dark Push). |
| **Real-world Analogy** | Ordering food from a restaurant ‚Üí you get one dish at a time.                                              | Choosing a cuisine (Italian, Indian) ‚Üí you get a full meal set (starter, main, dessert) in that theme.                 |
| **Java Examples**      | `Calendar.getInstance()`                                                                                   | `DocumentBuilderFactory`, `TransformerFactory`                                                                         |
| **When to Use**        | When you need to **decouple object creation** for one product type.                                        | When you need to **ensure consistency across multiple related products**.                                              |

---

‚úÖ **Interview Tip**: If asked

- _Factory Method_ ‚Üí single product, flexible instantiation.
    
- _Abstract Factory_ ‚Üí families of related products, theme consistency.
    

---

Let‚Äôs visualize both patterns side by side with **simple ASCII diagrams**.

---

## üè≠ Factory Method (Single Product)

```
Client
   |
   v
 NotificationFactory
   |
   +-- createNotification("EMAIL") ---> EmailNotification
   +-- createNotification("SMS")   ---> SMSNotification
   +-- createNotification("PUSH")  ---> PushNotification
```

‚û°Ô∏è The **Factory** decides _which single notification object_ to create.

---

## üè≠ Abstract Factory (Families of Products)

```
Client
   |
   v
 ThemeFactory
   |
   +-- LightThemeFactory ---------+
   |                              |
   |   +-- createEmail() ---> LightEmailNotification
   |   +-- createSMS()   ---> LightSMSNotification
   |   +-- createPush()  ---> LightPushNotification
   |
   +-- DarkThemeFactory ----------+
       |                          |
       +-- createEmail() ---> DarkEmailNotification
       +-- createSMS()   ---> DarkSMSNotification
       +-- createPush()  ---> DarkPushNotification
```

‚û°Ô∏è The **Abstract Factory** ensures that all created notifications **belong to the same family** (Light or Dark).

---

üîë **How to recall in interviews:**

- Factory = One object.
    
- Abstract Factory = Set of related objects.
    

---
