---
tags:
  - Java
  - DesignPattern
---

**Builder Design Pattern** is one of the GoF **Creational patterns**, and it’s very useful to understand for both coding and interviews. Let’s go step by step:

---

## 🔹 Problem it Solves

Sometimes, objects are **complex to construct** (many optional fields, combinations, validation).

- If we use a **constructor with many parameters**, code becomes unreadable:
    

```java
// Confusing constructor with many parameters
User user = new User("John", "Doe", 30, "john@example.com", "123 Street", "Engineer");
```

- With **setters**, the object may become mutable and inconsistent (partially initialized).
    

👉 The **Builder Pattern** solves this by providing a **step-by-step object construction process** with readable code.

---

## 🔹 Definition

The **Builder Pattern**:

- Separates the **construction of a complex object** from its representation.
    
- Lets you create different representations of an object using the same construction process.
    
- Provides a **fluent API** (method chaining).
    

---

## 🔹 UML Idea

```
Director (optional) → calls → Builder → constructs → Product
```

But in Java, we often implement a **static nested Builder class** inside the target object.

---

## 🔹 Example (Java – Without Lombok)

### User Class with Builder

```java
public class User {
    // Required fields
    private final String firstName;
    private final String lastName;

    // Optional fields
    private final int age;
    private final String email;
    private final String address;

    // Private constructor
    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.email = builder.email;
        this.address = builder.address;
    }

    // Static nested Builder class
    public static class Builder {
        private final String firstName;  // required
        private final String lastName;   // required
        private int age;                 // optional
        private String email;            // optional
        private String address;          // optional

        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

### Using the Builder

```java
public class Main {
    public static void main(String[] args) {
        User user = new User.Builder("John", "Doe")
                            .age(30)
                            .email("john@example.com")
                            .address("123 Street")
                            .build();

        System.out.println("User created: " + user);
    }
}
```

---

## 🔹 Real-Life Analogy

Think of **ordering a pizza** 🍕:

- Base (mandatory: crust, size).
    
- Optional toppings (cheese, olives, peppers, etc.).
    
- You don’t need all toppings, just pick what you want.
    
- Builder pattern allows **flexible combinations** without messy constructors.
    

---

## 🔹 Builder in Spring Boot

- Many Spring Boot classes internally use **Builder** (e.g., `ResponseEntity`, `MockMvcRequestBuilders`, `UriComponentsBuilder`).
    

```java
return ResponseEntity.ok()
                     .header("Custom-Header", "value")
                     .body("Hello World");
```

This is a **builder pattern in action** — you chain methods to build the final object.

---

## 🔹 Key Benefits

1. **Readable & flexible** object creation.
    
2. Avoids telescoping constructors (constructor with too many parameters).
    
3. Immutable objects (fields set only via Builder).
    
4. Good for objects with **optional parameters**.
    

---

✅ Interview Answer:  
_"The Builder Pattern is a creational design pattern that helps construct complex objects step by step. It’s especially useful when an object has many optional parameters. Instead of using a constructor with many arguments, we use a builder class that allows method chaining, resulting in clean and readable object creation. In Spring Boot, classes like ResponseEntity and UriComponentsBuilder use this pattern extensively."_

---

**Builder Design Pattern** shines in the real world whenever we deal with **complex objects with many optional or configurable parts**. Let’s go through some **real-world examples & use cases** (including Java/Spring Boot ones):

---

## 🔹 1. **Object Creation with Many Optional Fields**

### Example: **User Profile / Employee**

- Mandatory: `id`, `name`.
    
- Optional: `email`, `address`, `phone`, `social links`, `bio`, etc.  
    Using **Builder**, you only set the fields you need, without telescoping constructors.
    

👉 **Real-world analogy**: Filling a LinkedIn profile — some fields are mandatory, others optional.

---

## 🔹 2. **Immutable Objects**

Builder is great for creating **immutable classes**.

- Example: `java.lang.StringBuilder` (not GoF, but inspired by the same idea).
    
- Example: `java.lang.StringBuffer`.
    
- Example: `Lombok @Builder` generates builder methods for immutable entities.
    

---

## 🔹 3. **API Response Construction (Spring Boot)**

Spring Boot often uses builder-like methods:

```java
return ResponseEntity
        .status(HttpStatus.CREATED)
        .header("Custom-Header", "Value")
        .body("Resource created!");
```

✅ Clean, readable API response building.

---

## Execution flow of the Builder Pattern
### 🧱 Example Recap

We have the following `User` class with an inner `Builder` class:

```java
public class User {
    private final String firstName;
    private final String lastName;
    private final int age;
    private final String email;
    private final String address;

    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.email = builder.email;
        this.address = builder.address;
    }

    public static class Builder {
        private final String firstName;
        private final String lastName;
        private int age;
        private String email;
        private String address;

        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

And we use it like this:

```java
public class Main {
    public static void main(String[] args) {
        User user = new User.Builder("John", "Doe")
                            .age(30)
                            .email("john@example.com")
                            .address("123 Street")
                            .build();

        System.out.println("User object created successfully!");
    }
}
```

---

## 🔍 Step-by-Step Execution Flow

### **Step 1️⃣: Start main()**

Execution begins in the `main` method.

```java
User user = new User.Builder("John", "Doe") ...
```

- The `new User.Builder("John", "Doe")` call executes the **Builder constructor**.
    
- Memory is allocated for a `Builder` object.
    
- Inside the constructor:
    
    ```java
    this.firstName = "John";
    this.lastName = "Doe";
    ```
    
- At this point, the builder object has only the **required fields** set.
    

---

### **Step 2️⃣: Call `age(30)`**

```java
.age(30)
```

- This invokes the `age()` method on the builder instance.
    
- Inside `age()`:
    
    ```java
    this.age = 30;
    return this;
    ```
    
- Returns the **same builder instance** (`this`) → allows **method chaining**.
    

---

### **Step 3️⃣: Call `email("john@example.com")`**

```java
.email("john@example.com")
```

- Sets the `email` field inside the builder:
    
    ```java
    this.email = "john@example.com";
    return this;
    ```
    
- Returns the same builder instance → still chaining.
    

---

### **Step 4️⃣: Call `address("123 Street")`**

```java
.address("123 Street")
```

- Sets the address field inside the builder:
    
    ```java
    this.address = "123 Street";
    return this;
    ```
    
- Again returns the same builder instance.
    

---

### **Step 5️⃣: Call `.build()`**

```java
.build()
```

- Now, the builder is fully configured with all required + optional fields.
    
- Inside `build()`:
    
    ```java
    return new User(this);
    ```
    
- This creates a **new User object** by passing the **builder itself** as a parameter to the `User` private constructor.
    

---

### **Step 6️⃣: Execute `User` Constructor**

```java
private User(Builder builder) {
    this.firstName = builder.firstName;
    this.lastName = builder.lastName;
    this.age = builder.age;
    this.email = builder.email;
    this.address = builder.address;
}
```

- The constructor **copies all values** from the builder into the immutable User fields.
    
- After this step, the `User` object is **fully initialized and immutable**.
    

---

### **Step 7️⃣: Return the User object**

- The newly created `User` instance is returned from `build()` → assigned to the `user` variable in `main`.
    

---

### **Step 8️⃣: Program completes**

```java
System.out.println("User object created successfully!");
```

- You now have a clean, readable, and safely constructed `User` object.
    

---

## 🧠 Summary of Flow

|Step|Method/Action|Class|What Happens|
|---|---|---|---|
|1|`new Builder("John","Doe")`|Builder|Required fields initialized|
|2|`.age(30)`|Builder|Optional field set; returns same Builder|
|3|`.email("john@example.com")`|Builder|Optional field set|
|4|`.address("123 Street")`|Builder|Optional field set|
|5|`.build()`|Builder|Creates and returns a new User|
|6|`User(Builder)`|User|Copies values into immutable fields|
|7|Return User|—|Final User object ready|
|8|Print message|Main|Program output|

---

## 🧩 Why This Flow Is Powerful

✅ **Controlled construction:** No half-built objects.  
✅ **Immutability:** User fields are `final`.  
✅ **Readability:** Easy-to-read chained method calls.  
✅ **Flexibility:** You can add new optional fields later without breaking old code.
